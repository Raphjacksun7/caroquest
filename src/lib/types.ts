// FILE: src/lib/types.ts
// PURPOSE: Defines the core data structures and type aliases used throughout the application.

/**
 * Represents the unique identifier for a player, restricted to 1 or 2.
 */
export type PlayerId = 1 | 2;

/**
 * Defines the color of a square on the board or a player's pawn.
 */
export type SquareColor = 'light' | 'dark';

/**
 * Represents the two main phases of the game.
 * - 'placement': Players are placing their initial pawns.
 * - 'movement': Players are moving their pawns on the board.
 */
export type GamePhase = 'placement' | 'movement';

/**
 * Represents a single pawn on the game board.
 */
export interface Pawn {
  /** A unique identifier for the pawn instance (e.g., generated by nanoid). */
  id: string; 
  /** The player who owns this pawn. */
  playerId: PlayerId;
  /** The visual color of the pawn, typically matching the player's color. */
  color: SquareColor; // This was SquareColor in gameLogic, ensure consistency if different
}

/**
 * Represents the state of a single square on the 8x8 board.
 */
export interface SquareState {
  /** The square's unique index from 0 (top-left) to 63 (bottom-right). */
  index: number; 
  /** The row of the square (0-7). */
  row: number; 
  /** The column of the square (0-7). */
  col: number; 
  /** The visual color of the square itself (e.g., for a checkerboard pattern). */
  boardColor: SquareColor; 
  /** The pawn currently occupying this square, or null if the square is empty. */
  pawn: Pawn | null;
  /** Optional visual highlight state for UI feedback. */
  highlight?: 'selectedPawn' | 'validMove' | 'deadZoneIndicator';
}

/**
 * Defines the configurable options for creating a new game.
 */
export interface GameOptions {
  /** If true, the game can be listed publicly for other players to join. */
  isPublic?: boolean; 
  /** An optional, specific ID to use for the game room. */
  gameIdToCreate?: string;
  /** The number of pawns each player starts with. */
  pawnsPerPlayer?: number;
  /** If true, this game was created via automated matchmaking. */
  isMatchmaking?: boolean; 
  /** If true, the game's outcome will affect player ratings. */
  isRanked?: boolean;      
}

/**
 * Encapsulates the entire state of a game at a specific moment.
 */
export interface GameState {
  /** An array of 64 SquareState objects representing the game board. */
  board: SquareState[];
  /** The PlayerId of the player whose turn it is. */
  currentPlayerId: PlayerId;
  /** A mapping of player IDs to their assigned square color preference. */
  playerColors: Record<PlayerId, SquareColor>; 
  /** The current phase of the game. */
  gamePhase: GamePhase;
  /** Tracks the number of pawns each player has yet to place. */
  pawnsToPlace: Record<PlayerId, number>;
  /** Tracks the number of pawns each player has successfully placed. */
  placedPawns: Record<PlayerId, number>; 
  /** The index of the currently selected pawn for a move, or null. */
  selectedPawnIndex: number | null; 
  /** A set of square indices containing pawns that are currently blocked. */
  blockedPawnsInfo: Set<number>;
  /** A set of square indices containing pawns that are part of a blocking formation. */
  blockingPawnsInfo: Set<number>;
  /** A map of square indices that are dead zones, and the PlayerId of the player for whom it is a dead zone. */
  deadZoneSquares: Map<number, PlayerId>; 
  /** A set of square indices containing pawns that were responsible for creating a dead zone. */
  deadZoneCreatorPawnsInfo: Set<number>;
  /** The PlayerId of the winning player, or null if the game is ongoing. */
  winner: PlayerId | null;
  /** Information about the last move made. */
  lastMove: { from: number | null, to: number } | null; 
  /** An array of square indices forming the winning line, if a player has won. */
  winningLine: number[] | null; 
  /** An array of square indices representing valid moves for the currently selected pawn. */
  highlightedValidMoves?: number[];
  /** The game options that this game was created with. */
  options: GameOptions; // Made non-optional, will have defaults
}

/**
 * Represents a player's data as stored on the server.
 */
export interface StoredPlayer {
  /** The player's unique socket ID. */
  id: string;
  /** The player's display name. */
  name: string;
  /** The player's assigned ID within the game (1 or 2). */
  playerId: PlayerId; 
  /** Whether the player is currently connected. */
  isConnected: boolean; 
  /** Whether this player created the game room. */
  isCreator: boolean;
  /** Optional Elo rating for ranked matchmaking. */
  rating?: number;
}

/**
 * Defines the different modes the game can be played in.
 */
export type GameMode = "ai" | "local" | "remote" | "select";

/**
 * Defines the strategic modes for the AI opponent.
 * - 'normal': Balanced play with quick decisions, good at defensive placement
 * - 'aggressive': Defensive-first strategy, prioritizes blocking over winning
 */
export type AIStrategy = "normal" | "aggressive";

/**
 * Represents a single action that can be undone/redone.
 */
export interface GameAction {
  type: 'place' | 'move';
  squareIndex?: number;  // For placement
  fromIndex?: number;    // For movement
  toIndex?: number;      // For movement
}

/**
 * Represents a single entry in the game history for undo/redo functionality.
 */
export interface HistoryEntry {
  /** The complete game state at this point */
  gameState: GameState;
  /** The action that led to this state (null for initial state) */
  action: GameAction | null;
  /** The player who performed the action */
  playerId: PlayerId | null;
  /** Timestamp when the action was performed */
  timestamp: number;
  /** Move number in the game */
  moveNumber: number;
}

/**
 * Undo request status for online games
 */
export type UndoRequestStatus = 'pending' | 'accepted' | 'declined' | 'expired';

/**
 * Undo request data for online multiplayer
 */
export interface UndoRequest {
  requestId: string;
  requestedBy: PlayerId;
  requestedAt: number;
  status: UndoRequestStatus;
  movesToUndo: number; // How many moves to undo (1 for normal, 2 for AI mode)
}

export type Locale = 'en' | 'fr'; // Extend this as needed for more languages


// Enhanced types for the dynamic info system
export interface InfoAction {
  label: string;
  onClick: () => void;
  variant?: "default" | "outline" | "ghost" | "destructive" | "secondary";
  disabled?: boolean;
  loading?: boolean;
}

export type InfoType = 
  | "turn"          // Current player's turn
  | "winner"        // Game winner announcement
  | "request"       // Rematch/game requests
  | "error"         // Error messages
  | "info"          // General information
  | "success"       // Success messages
  | "warning"       // Warning messages
  | "waiting"       // Waiting states
  | "connection"    // Connection status
  | "notification"; // General notifications

export interface InfoBoxData {
  id: string;
  type: InfoType;
  message: string;
  actions?: InfoAction[];
  duration?: number;        // Auto-dismiss after X ms
  persistent?: boolean;     // Don't auto-dismiss even with duration
  dismissible?: boolean;    // Can be manually dismissed
  onDismiss?: () => void;   // Callback when dismissed
  priority?: number;        // Higher priority shows first (default: 0)
  icon?: React.ComponentType<{ className?: string }>; // Optional icon component
  metadata?: Record<string, any>; // Additional data for complex scenarios
}

export interface UseInfoSystemReturn {
  infos: InfoBoxData[];
  addInfo: (info: Omit<InfoBoxData, "id">) => string;
  removeInfo: (id: string) => void;
  clearInfos: () => void;
  clearInfosByType: (type: InfoType) => void;
  updateInfo: (id: string, updates: Partial<InfoBoxData>) => void;
  hasInfoOfType: (type: InfoType) => boolean;
  getInfosByType: (type: InfoType) => InfoBoxData[];
  getInfoById: (id: string) => InfoBoxData | undefined;
  replaceInfo: (type: InfoType, info: Omit<InfoBoxData, "id">) => string;
  addTemporaryInfo: (info: Omit<InfoBoxData, "id" | "duration">, duration: number) => string;
}